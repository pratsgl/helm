# Helm Charts

### What is helm ?
Helm (site) is an open-source Kubernetes package and operations manager. A Helm Chart at its minimum will contain a deployment and a service, but can contain any number of Kubernetes objects, for example ingress and persistent Volume Claims.

### Why would we use Helm?

We have already learned that a Helm Chart is used to deploy an application or even as a part of a larger application deployment strategy. There are many official Helm Charts, which can be downloaded from their respective repositories. Because they utilize an open-source licensing model you are free to use as-is or modify to suit your purpose. For example modify a Helm Chart to install a PostgreSQL container rather than a MySQL one.

The power of a Helm Chart is clear. It simplifies software deployment (installation, configuration, integration). Helm is a layer of abstraction that can simplify deployment whilst providing a method of repeatability, which in turn brings stability – and stability is one of the core pillars of operational desires.

### Customizing your Helm Environment

Currently we have only added the standard Helm repository, but you will want to create your own Charts that are customized for your environment. As your customized Charts cannot be easily be hosted on the default repository; this will mean hosting your own repository. Fortunately, this is easy as a Helm repository is effectively any HTTPS server that can service yaml, tar files and answer GET requests. 

### What does a Helm Chart look like?

At its most basic a Helm Chart is a yaml file. You will need to get acquainted with these if you want to deploy your own custom applications.

To generate a skeleton Chart you use the following command (chartname is your name for your Chart):

$ helm create buildachart

$ find .
.
./buildchart
./buildchart/.helmignore
./buildchart/values.yaml
./buildchart/Chart.yaml
./buildchart/charts
./buildchart/templates
./buildchart/templates/serviceaccount.yaml
./buildchart/templates/_helpers.tpl
./buildchart/templates/ingress.yaml
./buildchart/templates/deployment.yaml
./buildchart/templates/NOTES.txt
./buildchart/templates/tests
./buildchart/templates/tests/test-connection.yaml
./buildchart/templates/service.yaml

This creates a values.yaml file, a template folder that contains three more yaml files; deployment, ingress and service. Amongst a number of other files as outlined below:

#### How do these files map together?
 It is in here that Helm finds the YAML definitions for your Services, Deployments and other Kubernetes objects. If you have already generated definitions for your application, all you need to do is replace the generated empty YAML files for your own and voila, you have a working Chart that you can simply deploy using the helm install command.

Helm uses Go to run each of the files in the templates directory using the template rendering engine, Helm has extended the template language by adding a number of utility functions for writing Charts.

### Installation steps 

$ helm install --dry-run --debug release1 buildchart-0.1.0.tgz    

When the Chart is deployed Helm well generate a definition that will look more like a valid service, we can dry-run this with the following command.

Let’s have a quick look at the service.yaml file that is auto-generated by the creation command.

The next file to take note of is the values.yaml file. This is effectively a variables file; here you can see two variables that relate to the ingress and target port for the application.

if you desire a different value from that in your values.yaml file, you can override the values.yaml file by directly setting the value on the command line .
We can see that later at "upgrade" section 

The next file to look at is the NOTES.txt file this is effectively your Chart documentation, this is a templated file that is printed out after the Chart has successfully deployed.

### Deploying your first Helm Chart


vi ./buildchart/values.yaml 
<make required changes> 
When your Chart is ready, you can use this command to create a .tgz package:

helm package buildchart

You can upload this package to your Chart repository, or install it to your cluster. You can also install or upgrade the Chart without packaging it first.

First, install your Chart “chartname”:

 method 1 :  $ helm install release1 buildchart-0.1.0.tgz  

Or

method 2:    helm install my-cherry-chart buildachart/ --values buildachart/values.yaml 


$ kubectl get nodes --namespace default -o jsonpath="{.items[0].status.addresses[0].address}"

$ kubectl get --namespace default -o jsonpath="{.spec.ports[0].nodePort}" services cherry-chart

Open Browser and check with NodePort & Port

$ helm list   or /     helm ls -n mytools

### Upgrade : 
To make changes, update the version number in chart.yaml. Package the Chart, and upgrade.

Copy values.yaml to override-values.yaml - change replicas to "2"

$ helm upgrade -f values.yaml -f override-values.yaml release1 ./../buildchart -n mytools  [ you should be inside respective chart folder] 

$ helm list -n mytools

### Rollback 

$ helm rollback release1 1 -n mytools

$ helm list -n mytools  [watch "REVISION" number changes ]

$ kubectl get secrets -n mytools


$helm delete  release1

### Install on diff namespace

helm install release1 buildchart-0.1.0.tgz -n mytools 

### Delete the deployment.

helm delete release1  -n mytools

Resources :

- https://opensource.com/article/20/5/helm-charts
- https://medium.com/bb-tutorials-and-thoughts/how-to-get-started-with-helm-b3babb30611f
- https://amazicworld.com/using-helm-to-package-and-deploy-container-applications/
