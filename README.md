# Helm Charts

### What is helm ?
Helm (site) is an open-source Kubernetes package and operations manager. A Helm Chart at its minimum will contain a deployment and a service, but can contain any number of Kubernetes objects, for example ingress and persistent Volume Claims.

### Why would we use Helm?
Helm really shines where Kubernetes didn't go. For instance, templating. The scope of the Kubernetes project is to deal with your containers for you, not your template files. 

This makes it overly difficult to create truly generic files to be used across a large team or a large organization with many different parameters that need to be set for each file.

And also, how do you version sensitive information using Git when template files are plain text?

The answer: Go templates. Helm allows you to add variables and use functions inside your template files. This makes it perfect for scalable applications that'll eventually need to have their parameters changed.

We have already learnt that a Helm Chart is used to deploy an application or even as a part of a larger application deployment strategy. There are many official Helm Charts, which can be downloaded from their respective repositories. Because they utilize an open-source licensing model you are free to use as-is or modify to suit your purpose. For example modify a Helm Chart to install a PostgreSQL container rather than a MySQL one.

The power of a Helm Chart is clear. It simplifies software deployment (installation, configuration, integration). Helm is a layer of abstraction that can simplify deployment whilst providing a method of repeatability, which in turn brings stability – and stability is one of the core pillars of operational desires.

### Customizing your Helm Environment

Currently we have only added the standard Helm repository, but you will want to create your own Charts that are customized for your environment. As your customized Charts cannot be easily be hosted on the default repository; this will mean hosting your own repository. Fortunately, this is easy as a Helm repository is effectively any HTTPS server that can service yaml, tar files and answer GET requests. 

### What does a Helm Chart look like?

At its most basic a Helm Chart is a yaml file. You will need to get acquainted with these if you want to deploy your own custom applications.

To generate a skeleton Chart you use the following command (chartname is your name for your Chart):
```console
$ helm create buildachart

$ find .
.
./buildchart
./buildchart/.helmignore
./buildchart/values.yaml
./buildchart/Chart.yaml
./buildchart/charts
./buildchart/templates
./buildchart/templates/serviceaccount.yaml
./buildchart/templates/_helpers.tpl
./buildchart/templates/ingress.yaml
./buildchart/templates/deployment.yaml
./buildchart/templates/NOTES.txt
./buildchart/templates/tests
./buildchart/templates/tests/test-connection.yaml
./buildchart/templates/service.yaml
```
This creates a values.yaml file, a template folder that contains three more yaml files; deployment, ingress and service. Amongst a number of other files as outlined below:

#### How do these files map together?
 It is in here that Helm finds the YAML definitions for your Services, Deployments and other Kubernetes objects. If you have already generated definitions for your application, all you need to do is replace the generated empty YAML files for your own and voila, you have a working Chart that you can simply deploy using the helm install command.

Helm uses Go to run each of the files in the templates directory using the template rendering engine, Helm has extended the template language by adding a number of utility functions for writing Charts.

### Installation steps 

When the Chart is deployed Helm well generate a definition that will look more like a valid service, we can dry-run this with the following command.

Let’s have a quick look at the service.yaml file that is auto-generated by the creation command.

The next file to take note of is the values.yaml file. This is effectively a variables file; here you can see two variables that relate to the ingress and target port for the application.

if you desire a different value from that in your values.yaml file, you can override the values.yaml file by directly setting the value on the command line .
We can see that later at "upgrade" section 

The next file to look at is the NOTES.txt file this is effectively your Chart documentation, this is a templated file that is printed out after the Chart has successfully deployed.

### Deploying your first Helm Chart
```console
vi ./buildchart/values.yaml 
```
Customize changes
When your Chart is ready, you can use this command to create a .tgz package:
```console
helm package buildchart
```
You can upload this package to your Chart repository, or install it to your cluster. You can also install or upgrade the Chart without packaging it first.

First, install your Chart “chartname”:

 #### method 1 (with dryrun) : 
 ``` console
  
 $ helm install --dry-run --debug release1 buildchart-0.1.0.tgz    

install.go:149: [debug] Original chart version: ""
install.go:166: [debug] CHART PATH: /home/user/projects/helm/buildchart-0.2.0.tgz

NAME: release2
LAST DEPLOYED: Tue May 18 10:47:19 2021
NAMESPACE: default
STATUS: pending-install
REVISION: 1
USER-SUPPLIED VALUES:
{}

COMPUTED VALUES:
affinity: {}
fullnameOverride: cherry-chart
image:
  pullPolicy: Always
  repository: nginx
imagePullSecrets: []
ingress:
  annotations: {}
  enabled: false
  hosts:
  - host: chart-example.local
    paths: []
  tls: []
nameOverride: cherry-awesome-app
nodeSelector: {}
podSecurityContext: {}
replicaCount: 2
resources:
  limits:
    cpu: 100m
    memory: 128Mi
  requests:
    cpu: 100m
    memory: 128Mi
securityContext: {}
service:
  port: 80
  type: NodePort
serviceAccount:
  create: true
  name: cherrybomb
tolerations: []

HOOKS:
---
# Source: buildchart/templates/tests/test-connection.yaml
apiVersion: v1
kind: Pod
metadata:
  name: "cherry-chart-test-connection"
  labels:

    helm.sh/chart: buildchart-0.2.0
    app.kubernetes.io/name: cherry-awesome-app
    app.kubernetes.io/instance: release2
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
  annotations:
    "helm.sh/hook": test-success
spec:
  containers:
    - name: wget
      image: busybox
      command: ['wget']
      args:  ['cherry-chart:80']
  restartPolicy: Never
MANIFEST:
---
# Source: buildchart/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cherrybomb
  labels:

    helm.sh/chart: buildchart-0.2.0
    app.kubernetes.io/name: cherry-awesome-app
    app.kubernetes.io/instance: release2
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
---
# Source: buildchart/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: cherry-chart
  labels:
    helm.sh/chart: buildchart-0.2.0
    app.kubernetes.io/name: cherry-awesome-app
    app.kubernetes.io/instance: release2
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: cherry-awesome-app
    app.kubernetes.io/instance: release2
---
# Source: buildchart/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cherry-chart
  labels:
    helm.sh/chart: buildchart-0.2.0
    app.kubernetes.io/name: cherry-awesome-app
    app.kubernetes.io/instance: release2
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: cherry-awesome-app
      app.kubernetes.io/instance: release2
  template:
    metadata:
      labels:
        app.kubernetes.io/name: cherry-awesome-app
        app.kubernetes.io/instance: release2
    spec:
      serviceAccountName: cherrybomb
      securityContext:
        {}
      containers:
        - name: buildchart
          securityContext:
            {}
          image: "nginx:1.16.0"
          imagePullPolicy: Always
          ports:
            - name: http
              containerPort: 80
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /
              port: http
          readinessProbe:
            httpGet:
              path: /
              port: http
          resources:
            limits:
              cpu: 100m
              memory: 128Mi
            requests:
              cpu: 100m
              memory: 128Mi

NOTES:
1. Get the application URL by running these commands:
  export NODE_PORT=$(kubectl get --namespace default -o jsonpath="{.spec.ports[0].nodePort}" services cherry-chart)
  export NODE_IP=$(kubectl get nodes --namespace default -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT

 ```
 #### Installation 
```console
$ helm install  release2 buildchart-0.2.0.tgz -n staging
NAME: release2
LAST DEPLOYED: Tue May 18 10:47:40 2021
NAMESPACE: staging
STATUS: deployed
REVISION: 1
NOTES:
1. Get the application URL by running these commands:
  export NODE_PORT=$(kubectl get --namespace staging -o jsonpath="{.spec.ports[0].nodePort}" services cherry-chart)
  export NODE_IP=$(kubectl get nodes --namespace staging -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT
```
 ```console
 $ helm install release1 buildchart-0.1.0.tgz  
 ```
Or

#### method 2 : [by passing absolue path of values file]   
```console
helm install my-cherry-chart buildachart/ --values buildachart/values.yaml 
```
Check resources on K8s cluster
```console
$ kubectl get nodes --namespace default -o jsonpath="{.items[0].status.addresses[0].address}"
$ kubectl get --namespace default -o jsonpath="{.spec.ports[0].nodePort}" services cherry-chart
```
Open Browser and check with NodePort & Port
List the helm releases – you should see a generated deployment name with the Docker image designated by “chartname”.

```console
$ helm list -n staging or helm ls -n staging
NAME    	NAMESPACE	REVISION	UPDATED                                	STATUS  	CHART           	APP VERSION
release2	staging  	1       	2021-05-18 10:47:40.609466405 +0530 IST	deployed	buildchart-0.2.0	1.16.0 
```
### Upgrade : 
To make changes, update the version number in chart.yaml. Package the Chart, and upgrade.

Copy values.yaml to override-values.yaml - change replicas to "2"
```console
$ helm upgrade -f values.yaml -f override-values.yaml release1 ./../buildchart -n staging  [ you should be inside respective chart folder] 
Release "release1" has been upgraded. Happy Helming!
NAME: release1
LAST DEPLOYED: Tue May 18 10:39:15 2021
NAMESPACE: staging
STATUS: deployed
REVISION: 2
NOTES:
1. Get the application URL by running these commands:
  export NODE_PORT=$(kubectl get --namespace staging -o jsonpath="{.spec.ports[0].nodePort}" services cherry-chart)
  export NODE_IP=$(kubectl get nodes --namespace staging -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT

$ helm list -n staging
NAME    	NAMESPACE	REVISION	UPDATED                                	STATUS  	CHART           	APP VERSION
release1	staging  	2       	2021-05-18 10:39:15.494479617 +0530 IST	deployed	buildchart-0.1.0	1.16.0
```
### Rollback 
```console
$ helm rollback release1 1 -n staging
Rollback was a success! Happy Helming!

$ helm list -n staging [watch "REVISION" number changes ]
NAME    	NAMESPACE	REVISION	UPDATED                                	STATUS  	CHART           	APP VERSION
release1	staging  	3       	2021-05-18 10:42:02.056325362 +0530 IST	deployed	buildchart-0.1.0	1.16.0  

$ kubectl get secrets -n staging
```

### Install on diff namespace
```console
helm install release1 buildchart-0.1.0.tgz -n staging 
```
### Delete the deployment.
```console
helm delete release1  -n staging
```
#### Conclusion

Helm is here to stay. It has helped and will help a lot of Kubernetes developers out there for a long time. 
If you want to know how to use Helm, you can refer to their docs: https://helm.sh/

Resources :
- https://opensource.com/article/20/5/helm-charts
- https://medium.com/bb-tutorials-and-thoughts/how-to-get-started-with-helm-b3babb30611f
- https://amazicworld.com/using-helm-to-package-and-deploy-container-applications/

